## TODO

docker run base
process-shell
pb server mode
exit routine (copy files in resultdir (_RUN_WD)



----------

MAP (String,ModuleParamVal)
_MAP output type MAP
refactor RunEnv args (MAP) + resolve var , etc.



---------

refactor Moduledef (initinputs/outpus class methods overriden in builtin modules objects)


----------

shared object / global/run/module mutable variable (db, var, file, dir, ...)


------------


cpm process results (get)


----------------


- add DB Type
- finished normalization Types (map, list, etc.)
- normalization file/dir creation output in resultdir
- process/env serialization
- result management
- process lazy run (fetch previous run partial results)
- normalize cpm packaging


----------------


solve client/server issues (conf, corpus data, etc.) => (cli can send local conf file to server)
fix _CMD/results path consistance/cohÃ©rence => (every file/folder output should have its parentFolder created if needed in server space, every missing input path file missing reference should trigger and error. => every module MUST have static linked/packaged libraries (in docker, or specified shared environnement => docker also (specification system))
every docker files modifications (outputs) MUST be registered/reference on server space, every module input MUST be available to docker environment
custom dockerfile can be created but they must have their entrypoint be set to the properly installed script cpm-process-shell.py

creation custom type CORPUS,DB
base types BOOLEAN, VAL(string/yaml)
base default types FILE, DIR

implement _FILTER, _SPLITTER(filter on file content), _MATCH(sorte de if)(Boolean system => Boolean type, Boolean arithmÃ©tic (=, >=, <=, !=,&&,||), Boolean result between types(VAl,FILE,...) AbstractModuleVal => Boolean, (AbstractModuleVal, AbstractModuleVal,op) => Boolean (op appartient aux functions de l'arithmÃ©tique boolean)

stanford parser -> xml
xml_merger -> module

run result save, run module process db save,
run result = module process + env = moduleval = function + argument (argument and env can be void)
system to run some part of a module choosing and by default run result use as a moduleval with or without newenv input available
run types :
- (scratch/default) next same invocation + param : erase previous (can use previous output still during runing), different invocation or parameter create new run dir
- (saved) next same invocation + param : create a new run dir

can :
- can add a tag to any type
- save result for any type with added a tag (new if new, replace if not new)
- delete saved/unsaved results


pid = cpm run "module-name" conf(yaml) (= env yaml values)
pid = cpm new run "module-name" conf(yaml)
pid = cpm run "module-name" conf(yaml) --tag "tagname"
pid = cpm new run "module-name" conf(yaml) --tag "tagname"
cpm view PID OUTPUT
cpm view MODULE_NAME CONF OUTPUT --version "tagname(:pid)"
cpm view PID OUTPUT --gui // url to server rendering html default conversion (add format html for target implicit "view module" definitions) echoing file content/dir ls/..
cpm view PID OUTPUT --gui-debug // get the raw html produced by the server
cpm view PID OUTPUT --cpm-gui // get the raw html produced by the server with cpm-web-js use as library (for encapsulating views into cpm future neo4j style web ajax gui, use localstorage to store views command (pid/results) and be able to restore views after page refresh or views closed(does not destroy object))
(Tree(pid,status),status) = cpm process PID status

cpm run "module-name" conf --except "moduleval namespace" (comma separated list par exemple) // default replace moduleval by latest result, warning if no moduleval with same env initiation, error if no moduleval results available at all
cpm run "module-name" conf --replace "moduleval namespace = (tag(:pid))" (comma separated list par exemple) // force specific replace of a previous result









-------------------


How to implement a module with docker?
How to impove performance of multiple dockerized modules (shared librairies, memory overhead, images, containers)?

How to implement a module without docker?

Implement a process-shell for docker and without docker

Add DB Type :
[user:passwd]host:port@type
types : mysql, mongodb, neo4j/autre, triplestore(choose one)

Full Process Run Specification :

if not db.exist(moduledef) :
  db.create(moduledef)
  mkdir $result_dir/moduledef
listModuledefVersions  = db.get(moduledef)
if not listModuleVersions.exist(moduledef.version) :
  mkdir $result_dir/moduledef/moduledef.modificationDate
  listModulesvals = []
  listModuledefVersions.append(listModulesvals)
else :
  listModulevals = listModuleVersions.get(moduledef) # modulevals are moduledef x confs (=> flatMap against corpus version if handled)
if not listModulevals.exist(conf.serialize) : #string match
  mkdir $result_dir/moduledef/moduledef.modificationDate/hash(conf.serialize)
  listModulevalsversion = []
  listModulevals.append(listModulevalsversion)
else
  listModulevalsversion = listModulevals.get(conf)
version = len(listModulevalsversion)
runid = moduledef.runid++
mkdir $result_dir/moduledef/moduledef.modificationDate/hash(conf.serialize)/version
moduledef = status =
db.update(moduledef)

try {
  moduledef.toProcess(conf).run()
  status = success
}
except {
  status = failed
}

or !
if not db.exist(moduledef) :
  db.create(moduledef)
  mkdir $result_dir/moduledef
  git init $result_dir/moduledef

try {
  moduledef.toProcess(conf).run()
  status = success
}
except {
  status = failed
}

runid = moduledef.runid++
git add $result_dir/moduledef/. ; git commit -tag "moduledef.modificationDate|conf.serialize|runid"
db.update(moduledef)


=====

3 parameters apps :
- module_dirs
- corpus_dirs
- result_dirs

consider limits from possible not achievement in making them not only mutable on during booting.


